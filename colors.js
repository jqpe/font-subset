import postcss from 'postcss'
import { slate, slateDark, red, redDark } from '@radix-ui/colors'
import { writeFileSync, readFileSync } from 'node:fs'
import { execSync } from 'node:child_process'

const colorPalettes = {
  gray: {
    light: slate,
    dark: slateDark
  },
  red: {
    light: red,
    dark: redDark
  }
}

const generateStylesheet = () => {
  const root = postcss.root()
  const layer = postcss.atRule({ name: 'layer', params: 'colors' })

  Object.entries(colorPalettes).forEach(([name, palette]) => {
    const lightTheme = generateThemeRule(':root', name, palette.light)
    layer.append(lightTheme)

    const darkTheme = generateThemeRule(':root', name, palette.dark)
    const darkMediaQuery = postcss.atRule({
      name: 'media',
      params: '(prefers-color-scheme: dark)'
    })
    darkMediaQuery.append(darkTheme)
    layer.append(darkMediaQuery)

    layer.append(generateP3Theme(lightTheme, darkTheme))
  })

  root.append(layer)
  return root.toString()
}

const generateThemeRule = (selector, paletteName, colors) => {
  const rule = postcss.rule({ selector })
  Object.values(colors).forEach((value, i) => {
    rule.append({ prop: `--color-${paletteName}-${i + 1}`, value })
  })
  return rule
}

const generateP3Theme = (lightTheme, darkTheme) => {
  const fragments = []

  const supportsRule = postcss.atRule({
    name: 'supports',
    params: '(color: color(display-p3 1 1 1))'
  })
  const mediaRule = postcss.atRule({
    name: 'media',
    params: '(color-gamut: p3)'
  })

  const p3LightTheme = lightTheme.clone()
  p3LightTheme.walkDecls(decl => {
    decl.value = transformToP3(decl.value)
  })

  mediaRule.append(p3LightTheme)
  supportsRule.append(mediaRule)
  fragments.push(supportsRule)

  const darkSupportsRule = postcss.atRule({
    name: 'supports',
    params: '(color: color(display-p3 1 1 1))'
  })
  const darkP3MediaRule = postcss.atRule({
    name: 'media',
    params: '(color-gamut: p3) and (prefers-color-scheme: dark)'
  })

  const p3DarkTheme = darkTheme.clone()
  p3DarkTheme.walkDecls(decl => {
    decl.value = transformToP3(decl.value)
  })

  darkP3MediaRule.append(p3DarkTheme)
  darkSupportsRule.append(darkP3MediaRule)
  fragments.push(darkSupportsRule)

  return fragments
}

const transformToP3 = (/** @type {string} */ hex) => {
  const r = (parseInt(hex.slice(1, 3), 16) / 255).toPrecision(3)
  const g = (parseInt(hex.slice(3, 5), 16) / 255).toPrecision(3)
  const b = (parseInt(hex.slice(5, 7), 16) / 255).toPrecision(3)

  return `color(display-p3 ${r} ${g} ${b})`
}
const generatedFileComment =
  '/** This file was automatically generated by #/colors.js. MODIFY IT INSTEAD! */'

// Add this new function to generate Tailwind theme helper
const generateTailwindTheme = () => {
  const themeLayer = postcss.atRule({ name: 'theme', params: 'inline' })

  const resetTailwindDefaults = new postcss.Node({
    prop: '--color-*',
    value: 'initial'
  })

  themeLayer.append(resetTailwindDefaults)

  Object.entries(colorPalettes).forEach(([name, palette]) => {
    const nodes = Object.keys(palette.light).map((_, i) => {
      return new postcss.Node({
        prop: `--color-${name}-${i + 1}`,
        value: `var(--color-${name}-${i + 1})`
      })
    })
    themeLayer.append(...nodes)
  })

  return themeLayer.toString()
}

// Keep existing color.css generation
writeFileSync(
  './src/styles/colors.css',
  generatedFileComment + generateStylesheet()
)

const appendToIndexCss = content => {
  const indexCssPath = './src/styles/index.css'
  const existingContent = readFileSync(indexCssPath, 'utf-8')

  // Parse existing CSS
  const root = postcss.parse(existingContent)
  let themeRule = root.nodes.find(
    node =>
      node.type === 'atrule' &&
      node.name === 'theme' &&
      node.params === 'inline'
  )

  if (themeRule) {
    // Remove existing color rules
    themeRule.walkDecls(decl => {
      if (decl.prop.startsWith('--color-')) {
        decl.remove()
      }
    })

    // Parse and append new theme content
    const newTheme = postcss.parse(content)
    themeRule.append(newTheme.nodes[0].nodes)
  } else {
    // If no theme rule exists, proceed with original logic
    const importLines = existingContent
      .split('\n')
      .filter(line => line.trim().startsWith('@import'))
    const lastImportIndex = existingContent.lastIndexOf(
      importLines[importLines.length - 1]
    )

    const beforeImports = existingContent.slice(
      0,
      lastImportIndex + importLines[importLines.length - 1].length
    )
    const afterImports = existingContent.slice(
      lastImportIndex + importLines[importLines.length - 1].length
    )

    const newContent = beforeImports + '\n\n' + content + afterImports
    writeFileSync(indexCssPath, newContent)
    return
  }

  // Write the modified content back
  writeFileSync(indexCssPath, root.toString())
}
appendToIndexCss(generateTailwindTheme())

try {
  execSync('prettier --write ./src/styles/colors.css ./src/styles/index.css')
} catch (error) {
  console.error('Prettier transform failed: ', error)
}
